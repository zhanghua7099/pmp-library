<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Polygon Mesh Processing Library: algorithms</title>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0066bb">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <!-- Override right arrow icon from navtree.js -->
  <script type="text/javascript">
  var arrowRight = '&#9655;';
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://www.pmp-library.org"><img height=50 alt="Logo" src="pmp-logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Polygon Mesh Processing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">algorithms</div></div>
</div><!--header-->
<div class="contents">

<p>Mesh processing algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab0bc5cf882dd9adfbf56f396bde50fa6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gab0bc5cf882dd9adfbf56f396bde50fa6">Curvature</a> { <br />
&#160;&#160;<a class="el" href="group__algorithms.html#ggab0bc5cf882dd9adfbf56f396bde50fa6ad8bd79cc131920d5de426f914d17405a">min</a>
, <a class="el" href="group__algorithms.html#ggab0bc5cf882dd9adfbf56f396bde50fa6a2ffe4e77325d9a7152f7086ea7aa5114">max</a>
, <a class="el" href="group__algorithms.html#ggab0bc5cf882dd9adfbf56f396bde50fa6ab93db188572fc4d76cce5660f3823b0a">mean</a>
, <a class="el" href="group__algorithms.html#ggab0bc5cf882dd9adfbf56f396bde50fa6a710a4950250286365cf841f765a790f1">gauss</a>
, <br />
&#160;&#160;<a class="el" href="group__algorithms.html#ggab0bc5cf882dd9adfbf56f396bde50fa6a18077475a61518baca9368b586797902">max_abs</a>
<br />
 }</td></tr>
<tr class="memdesc:gab0bc5cf882dd9adfbf56f396bde50fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of curvature to be computed.  <a href="group__algorithms.html#gab0bc5cf882dd9adfbf56f396bde50fa6">More...</a><br /></td></tr>
<tr class="separator:gab0bc5cf882dd9adfbf56f396bde50fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga996dfb6992b4c623528f27664990deb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga996dfb6992b4c623528f27664990deb5">curvature</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="group__algorithms.html#gab0bc5cf882dd9adfbf56f396bde50fa6">Curvature</a> c=<a class="el" href="group__algorithms.html#ggab0bc5cf882dd9adfbf56f396bde50fa6ab93db188572fc4d76cce5660f3823b0a">Curvature::mean</a>, int smoothing_steps=0, bool use_tensor=false, bool use_two_ring=false)</td></tr>
<tr class="memdesc:ga996dfb6992b4c623528f27664990deb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-vertex curvature (min,max,mean,Gaussian).  <br /></td></tr>
<tr class="separator:ga996dfb6992b4c623528f27664990deb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ddc5af06c944e6bf29b3424704ab9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gae0ddc5af06c944e6bf29b3424704ab9f">decimate</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, unsigned int n_vertices, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> aspect_ratio=0.0, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> <a class="el" href="group__algorithms.html#gaa73faf69000512c8b2d23bba5fe8423e">edge_length</a>=0.0, unsigned int max_valence=0, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> normal_deviation=0.0, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> hausdorff_error=0.0, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> seam_threshold=1e-2, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> seam_angle_deviation=1)</td></tr>
<tr class="memdesc:gae0ddc5af06c944e6bf29b3424704ab9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh decimation based on approximation error and fairness criteria.  <br /></td></tr>
<tr class="separator:gae0ddc5af06c944e6bf29b3424704ab9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5603af99ab874d5aacdd373ed27242c8"><td class="memItemLeft" align="right" valign="top"><a id="ga5603af99ab874d5aacdd373ed27242c8" name="ga5603af99ab874d5aacdd373ed27242c8"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>clamp_cot</b> (const <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> v)</td></tr>
<tr class="memdesc:ga5603af99ab874d5aacdd373ed27242c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">clamp cotangent values as if angles are in [3, 177] <br /></td></tr>
<tr class="separator:ga5603af99ab874d5aacdd373ed27242c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2aedcd84a66af06cb05557e394aaa13"><td class="memItemLeft" align="right" valign="top"><a id="gad2aedcd84a66af06cb05557e394aaa13" name="gad2aedcd84a66af06cb05557e394aaa13"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>clamp_cos</b> (const <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> v)</td></tr>
<tr class="memdesc:gad2aedcd84a66af06cb05557e394aaa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">clamp cosine values as if angles are in [3, 177] <br /></td></tr>
<tr class="separator:gad2aedcd84a66af06cb05557e394aaa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa238acc663e940587f31fa2893c1a195"><td class="memItemLeft" align="right" valign="top"><a id="gaa238acc663e940587f31fa2893c1a195" name="gaa238acc663e940587f31fa2893c1a195"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>angle</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v0, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v1)</td></tr>
<tr class="memdesc:gaa238acc663e940587f31fa2893c1a195"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute angle between two (un-normalized) vectors <br /></td></tr>
<tr class="separator:gaa238acc663e940587f31fa2893c1a195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53fdfeff6ba660f321830887b9d6fb7b"><td class="memItemLeft" align="right" valign="top"><a id="ga53fdfeff6ba660f321830887b9d6fb7b" name="ga53fdfeff6ba660f321830887b9d6fb7b"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v0, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v1)</td></tr>
<tr class="memdesc:ga53fdfeff6ba660f321830887b9d6fb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute sine of angle between two (un-normalized) vectors <br /></td></tr>
<tr class="separator:ga53fdfeff6ba660f321830887b9d6fb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8d4bf0289a0d913dd7f63e267c4667"><td class="memItemLeft" align="right" valign="top"><a id="ga6a8d4bf0289a0d913dd7f63e267c4667" name="ga6a8d4bf0289a0d913dd7f63e267c4667"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v0, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v1)</td></tr>
<tr class="memdesc:ga6a8d4bf0289a0d913dd7f63e267c4667"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute cosine of angle between two (un-normalized) vectors <br /></td></tr>
<tr class="separator:ga6a8d4bf0289a0d913dd7f63e267c4667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e456cee3206da8b28d822cae61f4cd"><td class="memItemLeft" align="right" valign="top"><a id="ga39e456cee3206da8b28d822cae61f4cd" name="ga39e456cee3206da8b28d822cae61f4cd"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cotan</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v0, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v1)</td></tr>
<tr class="memdesc:ga39e456cee3206da8b28d822cae61f4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute cotangent of angle between two (un-normalized) vectors <br /></td></tr>
<tr class="separator:ga39e456cee3206da8b28d822cae61f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25b22a28545fce6bdb9112c22df5a06"><td class="memItemLeft" align="right" valign="top"><a id="gab25b22a28545fce6bdb9112c22df5a06" name="gab25b22a28545fce6bdb9112c22df5a06"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>triangle_area</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p0, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p1, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p2)</td></tr>
<tr class="memdesc:gab25b22a28545fce6bdb9112c22df5a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute area of a triangle given by three points <br /></td></tr>
<tr class="separator:gab25b22a28545fce6bdb9112c22df5a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435e465f8829b584ea80ffee23abfd0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga435e465f8829b584ea80ffee23abfd0f">face_area</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:ga435e465f8829b584ea80ffee23abfd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute area of face <code>f</code>.  <br /></td></tr>
<tr class="separator:ga435e465f8829b584ea80ffee23abfd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd217b8a37bedb1b9a33f6b5bc46a97"><td class="memItemLeft" align="right" valign="top"><a id="gafbd217b8a37bedb1b9a33f6b5bc46a97" name="gafbd217b8a37bedb1b9a33f6b5bc46a97"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>surface_area</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gafbd217b8a37bedb1b9a33f6b5bc46a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the surface area of <code>mesh</code> (as sum of face areas). <br /></td></tr>
<tr class="separator:gafbd217b8a37bedb1b9a33f6b5bc46a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4ee616cdfe46f98bd4ff7fd418f9d2"><td class="memItemLeft" align="right" valign="top"><a id="ga0d4ee616cdfe46f98bd4ff7fd418f9d2" name="ga0d4ee616cdfe46f98bd4ff7fd418f9d2"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>voronoi_area</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:ga0d4ee616cdfe46f98bd4ff7fd418f9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute (barycentric) Voronoi area of vertex v <br /></td></tr>
<tr class="separator:ga0d4ee616cdfe46f98bd4ff7fd418f9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ed1bf4ffbfb0fb6fd582cdb0019b1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga93ed1bf4ffbfb0fb6fd582cdb0019b1c">voronoi_area_mixed</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:ga93ed1bf4ffbfb0fb6fd582cdb0019b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mixed Voronoi area of a vertex.  <br /></td></tr>
<tr class="separator:ga93ed1bf4ffbfb0fb6fd582cdb0019b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48ef675f84e1ee4c021694c1f54d9164"><td class="memItemLeft" align="right" valign="top"><a id="ga48ef675f84e1ee4c021694c1f54d9164" name="ga48ef675f84e1ee4c021694c1f54d9164"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>edge_area</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:ga48ef675f84e1ee4c021694c1f54d9164"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute area assigned to edge e (a face with n edges assigns 1/n of its area to each edge) <br /></td></tr>
<tr class="separator:ga48ef675f84e1ee4c021694c1f54d9164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dfe15cf2f00acfdd1c06eb4347e629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga83dfe15cf2f00acfdd1c06eb4347e629">volume</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga83dfe15cf2f00acfdd1c06eb4347e629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the volume of a mesh.  <br /></td></tr>
<tr class="separator:ga83dfe15cf2f00acfdd1c06eb4347e629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c9ea739be800e71e0570807e39f78d"><td class="memItemLeft" align="right" valign="top"><a id="ga01c9ea739be800e71e0570807e39f78d" name="ga01c9ea739be800e71e0570807e39f78d"></a>
<a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>centroid</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:ga01c9ea739be800e71e0570807e39f78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute barycenter/centroid of a face <br /></td></tr>
<tr class="separator:ga01c9ea739be800e71e0570807e39f78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45db73aa98eeb9543cf1e64f5c2eeae1"><td class="memItemLeft" align="right" valign="top"><a id="ga45db73aa98eeb9543cf1e64f5c2eeae1" name="ga45db73aa98eeb9543cf1e64f5c2eeae1"></a>
<a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>centroid</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga45db73aa98eeb9543cf1e64f5c2eeae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">barycenter/centroid of mesh, computed as area-weighted mean of vertices. <br /></td></tr>
<tr class="separator:ga45db73aa98eeb9543cf1e64f5c2eeae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2da4e0cf0776841129157eded85dd76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gac2da4e0cf0776841129157eded85dd76">dual</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gac2da4e0cf0776841129157eded85dd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute dual of a mesh.  <br /></td></tr>
<tr class="separator:gac2da4e0cf0776841129157eded85dd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16503985229c4c2730cd0f76ba3153cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga16503985229c4c2730cd0f76ba3153cb">cotan_weight</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:ga16503985229c4c2730cd0f76ba3153cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the cotangent weight for edge e  <br /></td></tr>
<tr class="separator:ga16503985229c4c2730cd0f76ba3153cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9733adae31befb562a66d76b2892a24f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga9733adae31befb562a66d76b2892a24f">laplace</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:ga9733adae31befb562a66d76b2892a24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute Laplace vector for vertex v (normalized by Voronoi area)  <br /></td></tr>
<tr class="separator:ga9733adae31befb562a66d76b2892a24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ebd17d51c199465103e81830e796dc9"><td class="memItemLeft" align="right" valign="top"><a id="ga4ebd17d51c199465103e81830e796dc9" name="ga4ebd17d51c199465103e81830e796dc9"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dist_point_line_segment</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v0, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v1, <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;nearest_point)</td></tr>
<tr class="memdesc:ga4ebd17d51c199465103e81830e796dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance of a point p to a line segment given by points (v0,v1). <br /></td></tr>
<tr class="separator:ga4ebd17d51c199465103e81830e796dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c32372f096f9f5a9777cfa4f593a17"><td class="memItemLeft" align="right" valign="top"><a id="ga30c32372f096f9f5a9777cfa4f593a17" name="ga30c32372f096f9f5a9777cfa4f593a17"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dist_point_triangle</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v0, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v1, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;v2, <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;nearest_point)</td></tr>
<tr class="memdesc:ga30c32372f096f9f5a9777cfa4f593a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance of a point p to the triangle given by points (v0, v1, v2). <br /></td></tr>
<tr class="separator:ga30c32372f096f9f5a9777cfa4f593a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a7bf250a882d91f9c7733a6a2c4f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaf4a7bf250a882d91f9c7733a6a2c4f04">minimize_area</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gaf4a7bf250a882d91f9c7733a6a2c4f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize surface area.  <br /></td></tr>
<tr class="separator:gaf4a7bf250a882d91f9c7733a6a2c4f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca2a564e3160dcf10a2c9061a9d5e8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga6ca2a564e3160dcf10a2c9061a9d5e8f">minimize_curvature</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga6ca2a564e3160dcf10a2c9061a9d5e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize surface curvature.  <br /></td></tr>
<tr class="separator:ga6ca2a564e3160dcf10a2c9061a9d5e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf088d924e73a287814117be95e066e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaf088d924e73a287814117be95e066e65">fair</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, unsigned int k=2)</td></tr>
<tr class="memdesc:gaf088d924e73a287814117be95e066e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit surface fairing.  <br /></td></tr>
<tr class="separator:gaf088d924e73a287814117be95e066e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffad2e6a6859e0085355605048884f7f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaffad2e6a6859e0085355605048884f7f">detect_features</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> <a class="el" href="group__algorithms.html#gaa238acc663e940587f31fa2893c1a195">angle</a>)</td></tr>
<tr class="memdesc:gaffad2e6a6859e0085355605048884f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark edges with dihedral angle larger than <code>angle</code> as feature.  <br /></td></tr>
<tr class="separator:gaffad2e6a6859e0085355605048884f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9238a9388000b87d264c559487a65372"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga9238a9388000b87d264c559487a65372">detect_boundary</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga9238a9388000b87d264c559487a65372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all boundary edges as features.  <br /></td></tr>
<tr class="separator:ga9238a9388000b87d264c559487a65372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4171cccd05b114b3235b55273766e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaa4171cccd05b114b3235b55273766e19">clear_features</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gaa4171cccd05b114b3235b55273766e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear feature and boundary edges.  <br /></td></tr>
<tr class="separator:gaa4171cccd05b114b3235b55273766e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac111fa556be1ce658f8994ccd29e514d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gac111fa556be1ce658f8994ccd29e514d">geodesics</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;seeds, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> maxdist=std::numeric_limits&lt; <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> &gt;<a class="el" href="group__core.html#ga1df4a4cb5ca6aead30088c56290caf1e">::max</a>(), unsigned int maxnum=std::numeric_limits&lt; unsigned int &gt;<a class="el" href="group__core.html#ga1df4a4cb5ca6aead30088c56290caf1e">::max</a>(), std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; *neighbors=nullptr)</td></tr>
<tr class="memdesc:gac111fa556be1ce658f8994ccd29e514d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geodesic distance from a set of seed vertices.  <br /></td></tr>
<tr class="separator:gac111fa556be1ce658f8994ccd29e514d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10a5c5209c0e72ba7dd03a00d2f662a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gac10a5c5209c0e72ba7dd03a00d2f662a">geodesics_heat</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;seeds)</td></tr>
<tr class="memdesc:gac10a5c5209c0e72ba7dd03a00d2f662a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geodesic distance from a set of seed vertices.  <br /></td></tr>
<tr class="separator:gac10a5c5209c0e72ba7dd03a00d2f662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca9b37cec9b172bb897b8db8941b457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaaca9b37cec9b172bb897b8db8941b457">fill_hole</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:gaaca9b37cec9b172bb897b8db8941b457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the hole specified by halfedge <code>h</code>.  <br /></td></tr>
<tr class="separator:gaaca9b37cec9b172bb897b8db8941b457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fec1c728d2fafe2b201be4214898cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga8fec1c728d2fafe2b201be4214898cef">uniform_mass_matrix</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="namespacepmp.html#ae3249aafea03050084307e8b71f36be6">DiagonalMatrix</a> &amp;M)</td></tr>
<tr class="memdesc:ga8fec1c728d2fafe2b201be4214898cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the mass matrix for the uniform Laplacian.  <br /></td></tr>
<tr class="separator:ga8fec1c728d2fafe2b201be4214898cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6371fadb0df9378b3422b815c0bf189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gab6371fadb0df9378b3422b815c0bf189">uniform_laplace_matrix</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;L)</td></tr>
<tr class="memdesc:gab6371fadb0df9378b3422b815c0bf189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the uniform Laplace matrix.  <br /></td></tr>
<tr class="separator:gab6371fadb0df9378b3422b815c0bf189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9523db1a9d004baa313eaa436afdde1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga9523db1a9d004baa313eaa436afdde1e">mass_matrix</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="namespacepmp.html#ae3249aafea03050084307e8b71f36be6">DiagonalMatrix</a> &amp;M)</td></tr>
<tr class="memdesc:ga9523db1a9d004baa313eaa436afdde1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the (lumped) mass matrix for the cotangent Laplacian.  <br /></td></tr>
<tr class="separator:ga9523db1a9d004baa313eaa436afdde1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05321dedc35a3043d5cec49087cad399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga05321dedc35a3043d5cec49087cad399">laplace_matrix</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;L, bool clamp=false)</td></tr>
<tr class="memdesc:ga05321dedc35a3043d5cec49087cad399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the cotan Laplace matrix.  <br /></td></tr>
<tr class="separator:ga05321dedc35a3043d5cec49087cad399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c8e7f45d4ea5de4e1af8497a2a415d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga29c8e7f45d4ea5de4e1af8497a2a415d">gradient_matrix</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;G)</td></tr>
<tr class="memdesc:ga29c8e7f45d4ea5de4e1af8497a2a415d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the cotan gradient matrix.  <br /></td></tr>
<tr class="separator:ga29c8e7f45d4ea5de4e1af8497a2a415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2fab8863491412591b0b3ee13dfddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gadf2fab8863491412591b0b3ee13dfddf">divergence_matrix</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;D)</td></tr>
<tr class="memdesc:gadf2fab8863491412591b0b3ee13dfddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the cotan divergence matrix.  <br /></td></tr>
<tr class="separator:gadf2fab8863491412591b0b3ee13dfddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7fbd36d795764476f3d5cfbd720273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga2a7fbd36d795764476f3d5cfbd720273">coordinates_to_matrix</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="namespacepmp.html#ad57866758e73ec85f27ca57c46510795">DenseMatrix</a> &amp;X)</td></tr>
<tr class="memdesc:ga2a7fbd36d795764476f3d5cfbd720273"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a mesh with N vertices, construct an Nx3 matrix containing the vertex coordinates in its rows.  <br /></td></tr>
<tr class="separator:ga2a7fbd36d795764476f3d5cfbd720273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62cb07f432c4a57c565a3a2e480145a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga62cb07f432c4a57c565a3a2e480145a9">matrix_to_coordinates</a> (const <a class="el" href="namespacepmp.html#ad57866758e73ec85f27ca57c46510795">DenseMatrix</a> &amp;X, <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga62cb07f432c4a57c565a3a2e480145a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a mesh with N vertices, set the vertex coordinates from the rows of an Nx3 matrix.  <br /></td></tr>
<tr class="separator:ga62cb07f432c4a57c565a3a2e480145a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35975622025fb0fb0b9d6c70f1c1b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaa35975622025fb0fb0b9d6c70f1c1b6b">vertex_normals</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gaa35975622025fb0fb0b9d6c70f1c1b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex normals for the whole <code>mesh</code>.  <br /></td></tr>
<tr class="separator:gaa35975622025fb0fb0b9d6c70f1c1b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbdfb991afd1ba49d6ae568fffdc4c44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gadbdfb991afd1ba49d6ae568fffdc4c44">face_normals</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gadbdfb991afd1ba49d6ae568fffdc4c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face normals for the whole <code>mesh</code>.  <br /></td></tr>
<tr class="separator:gadbdfb991afd1ba49d6ae568fffdc4c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb42aa6dc03649f6078d3baeba7654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gacf26e6cb89ee46863792074a1d0a280b">Normal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gac5fb42aa6dc03649f6078d3baeba7654">vertex_normal</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:gac5fb42aa6dc03649f6078d3baeba7654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normal vector of vertex <code>v</code>.  <br /></td></tr>
<tr class="separator:gac5fb42aa6dc03649f6078d3baeba7654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7343f7734686d6ede26f20ef3f11b736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gacf26e6cb89ee46863792074a1d0a280b">Normal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga7343f7734686d6ede26f20ef3f11b736">face_normal</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:ga7343f7734686d6ede26f20ef3f11b736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normal vector of face <code>f</code>.  <br /></td></tr>
<tr class="separator:ga7343f7734686d6ede26f20ef3f11b736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e83a7ab6b982b4bfd33f60db107077f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gacf26e6cb89ee46863792074a1d0a280b">Normal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga9e83a7ab6b982b4bfd33f60db107077f">corner_normal</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> crease_angle)</td></tr>
<tr class="memdesc:ga9e83a7ab6b982b4bfd33f60db107077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normal vector of the polygon corner specified by the target vertex of halfedge <code>h</code>.  <br /></td></tr>
<tr class="separator:ga9e83a7ab6b982b4bfd33f60db107077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafdf2296336831cf5be5e6732b9fd301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaafdf2296336831cf5be5e6732b9fd301">harmonic_parameterization</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, bool use_uniform_weights=false)</td></tr>
<tr class="memdesc:gaafdf2296336831cf5be5e6732b9fd301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute discrete harmonic parameterization.  <br /></td></tr>
<tr class="separator:gaafdf2296336831cf5be5e6732b9fd301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f704761534c423c6adf1238e53bba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga29f704761534c423c6adf1238e53bba0">lscm_parameterization</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga29f704761534c423c6adf1238e53bba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute parameterization based on least squares conformal mapping.  <br /></td></tr>
<tr class="separator:ga29f704761534c423c6adf1238e53bba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddecfc2d08f5dbf820863acc79ee3bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga1ddecfc2d08f5dbf820863acc79ee3bc">uniform_remeshing</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> <a class="el" href="group__algorithms.html#gaa73faf69000512c8b2d23bba5fe8423e">edge_length</a>, unsigned int iterations=10, bool use_projection=true)</td></tr>
<tr class="memdesc:ga1ddecfc2d08f5dbf820863acc79ee3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform uniform remeshing.  <br /></td></tr>
<tr class="separator:ga1ddecfc2d08f5dbf820863acc79ee3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee81c99c293038da58ede01416bf8026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaee81c99c293038da58ede01416bf8026">adaptive_remeshing</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> min_edge_length, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> max_edge_length, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> approx_error, unsigned int iterations=10, bool use_projection=true)</td></tr>
<tr class="memdesc:gaee81c99c293038da58ede01416bf8026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform adaptive remeshing.  <br /></td></tr>
<tr class="separator:gaee81c99c293038da58ede01416bf8026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5ecdb5b08657b2898f8d6a0c9157cf"><td class="memItemLeft" align="right" valign="top"><a id="ga6f5ecdb5b08657b2898f8d6a0c9157cf" name="ga6f5ecdb5b08657b2898f8d6a0c9157cf"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tetrahedron</b> ()</td></tr>
<tr class="memdesc:ga6f5ecdb5b08657b2898f8d6a0c9157cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate tetrahedron. <br /></td></tr>
<tr class="separator:ga6f5ecdb5b08657b2898f8d6a0c9157cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a498f54aac73fa38633c8b5791d09e"><td class="memItemLeft" align="right" valign="top"><a id="ga98a498f54aac73fa38633c8b5791d09e" name="ga98a498f54aac73fa38633c8b5791d09e"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hexahedron</b> ()</td></tr>
<tr class="memdesc:ga98a498f54aac73fa38633c8b5791d09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate hexahedron. <br /></td></tr>
<tr class="separator:ga98a498f54aac73fa38633c8b5791d09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c9c10a47b4d8014247b648d6ba94cd0"><td class="memItemLeft" align="right" valign="top"><a id="ga4c9c10a47b4d8014247b648d6ba94cd0" name="ga4c9c10a47b4d8014247b648d6ba94cd0"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><b>octahedron</b> ()</td></tr>
<tr class="memdesc:ga4c9c10a47b4d8014247b648d6ba94cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate octahedron. <br /></td></tr>
<tr class="separator:ga4c9c10a47b4d8014247b648d6ba94cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5ee5e0eef3e6bb020bfda9eb6c4d20"><td class="memItemLeft" align="right" valign="top"><a id="gafc5ee5e0eef3e6bb020bfda9eb6c4d20" name="gafc5ee5e0eef3e6bb020bfda9eb6c4d20"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dodecahedron</b> ()</td></tr>
<tr class="memdesc:gafc5ee5e0eef3e6bb020bfda9eb6c4d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate dodecahedron. <br /></td></tr>
<tr class="separator:gafc5ee5e0eef3e6bb020bfda9eb6c4d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0f3178a9a969c055db9a57c563c6ec3"><td class="memItemLeft" align="right" valign="top"><a id="gad0f3178a9a969c055db9a57c563c6ec3" name="gad0f3178a9a969c055db9a57c563c6ec3"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><b>icosahedron</b> ()</td></tr>
<tr class="memdesc:gad0f3178a9a969c055db9a57c563c6ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate icosahedron. <br /></td></tr>
<tr class="separator:gad0f3178a9a969c055db9a57c563c6ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff49f97d35538c22214bcb08907578c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaff49f97d35538c22214bcb08907578c4">icosphere</a> (size_t n_subdivisions=3)</td></tr>
<tr class="memdesc:gaff49f97d35538c22214bcb08907578c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate icosphere refined by <code>n_subdivisions</code> .  <br /></td></tr>
<tr class="separator:gaff49f97d35538c22214bcb08907578c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fdffc976f947cf3e7911461295a9737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga2fdffc976f947cf3e7911461295a9737">quad_sphere</a> (size_t n_subdivisions=3)</td></tr>
<tr class="memdesc:ga2fdffc976f947cf3e7911461295a9737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate quad sphere refined by <code>n_subdivisions</code> .  <br /></td></tr>
<tr class="separator:ga2fdffc976f947cf3e7911461295a9737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b9014c3910d1966795baaaaad5ea3e"><td class="memItemLeft" align="right" valign="top"><a id="gab0b9014c3910d1966795baaaaad5ea3e" name="gab0b9014c3910d1966795baaaaad5ea3e"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><b>uv_sphere</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;center=<a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a>(0, 0, 0), <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> radius=1.0, size_t n_slices=15, size_t n_stacks=15)</td></tr>
<tr class="memdesc:gab0b9014c3910d1966795baaaaad5ea3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate UV sphere with given <code>center</code>, <code>radius</code>, <code>n_slices</code>, and <code>n_stacks</code>. <br /></td></tr>
<tr class="separator:gab0b9014c3910d1966795baaaaad5ea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae29d243d897921e656396a218cc17db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gae29d243d897921e656396a218cc17db2">plane</a> (size_t resolution=4)</td></tr>
<tr class="memdesc:gae29d243d897921e656396a218cc17db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a plane mesh.  <br /></td></tr>
<tr class="separator:gae29d243d897921e656396a218cc17db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cbc6cb993b7276c98aa6f94bf932f1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga4cbc6cb993b7276c98aa6f94bf932f1b">cone</a> (size_t n_subdivisions=30, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> radius=1.0, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> height=2.5)</td></tr>
<tr class="memdesc:ga4cbc6cb993b7276c98aa6f94bf932f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a cone mesh.  <br /></td></tr>
<tr class="separator:ga4cbc6cb993b7276c98aa6f94bf932f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2ed056e1accab921da9142ab7c4568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga6b2ed056e1accab921da9142ab7c4568">cylinder</a> (size_t n_subdivisions=30, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> radius=1.0, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> height=2.5)</td></tr>
<tr class="memdesc:ga6b2ed056e1accab921da9142ab7c4568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a cylinder mesh.  <br /></td></tr>
<tr class="separator:ga6b2ed056e1accab921da9142ab7c4568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d933cd48c728f9f45cd61c26a40e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gae7d933cd48c728f9f45cd61c26a40e25">torus</a> (size_t radial_resolution=20, size_t tubular_resolution=40, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> radius=1.0, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> thickness=0.4)</td></tr>
<tr class="memdesc:gae7d933cd48c728f9f45cd61c26a40e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a torus mesh.  <br /></td></tr>
<tr class="separator:gae7d933cd48c728f9f45cd61c26a40e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa24662ed3dcb46496f9da995ebc18d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gabfa24662ed3dcb46496f9da995ebc18d">explicit_smoothing</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, unsigned int iterations=10, bool use_uniform_laplace=false)</td></tr>
<tr class="memdesc:gabfa24662ed3dcb46496f9da995ebc18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform explicit Laplacian smoothing.  <br /></td></tr>
<tr class="separator:gabfa24662ed3dcb46496f9da995ebc18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e259304277c0853b3c1867b2bd8eab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gad0e259304277c0853b3c1867b2bd8eab">implicit_smoothing</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> timestep=0.001, unsigned int iterations=1, bool use_uniform_laplace=false, bool rescale=true)</td></tr>
<tr class="memdesc:gad0e259304277c0853b3c1867b2bd8eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform implicit Laplacian smoothing.  <br /></td></tr>
<tr class="separator:gad0e259304277c0853b3c1867b2bd8eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8904821f0ffb041f98a829595a4bbb81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga8904821f0ffb041f98a829595a4bbb81">catmull_clark_subdivision</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga8904821f0ffb041f98a829595a4bbb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one step of Catmull-Clark subdivision.  <br /></td></tr>
<tr class="separator:ga8904821f0ffb041f98a829595a4bbb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9902b2a584569ecb1cfaab42a70997d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gae9902b2a584569ecb1cfaab42a70997d">loop_subdivision</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gae9902b2a584569ecb1cfaab42a70997d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one step of Loop subdivision.  <br /></td></tr>
<tr class="separator:gae9902b2a584569ecb1cfaab42a70997d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2980af4c4d5308b711f92431a0f80d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga6c2980af4c4d5308b711f92431a0f80d">quad_tri_subdivision</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga6c2980af4c4d5308b711f92431a0f80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one step of quad-tri subdivision.  <br /></td></tr>
<tr class="separator:ga6c2980af4c4d5308b711f92431a0f80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb9055ec7d7d8c31e99bbfdfa57785a"><td class="memItemLeft" align="right" valign="top"><a id="ga6fb9055ec7d7d8c31e99bbfdfa57785a" name="ga6fb9055ec7d7d8c31e99bbfdfa57785a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>triangulate</b> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga6fb9055ec7d7d8c31e99bbfdfa57785a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate all faces in <code>mesh</code> by applying <a class="el" href="group__algorithms.html#ga6fb9055ec7d7d8c31e99bbfdfa57785a" title="Triangulate all faces in mesh by applying triangulate().">triangulate()</a>. <br /></td></tr>
<tr class="separator:ga6fb9055ec7d7d8c31e99bbfdfa57785a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa015ca35277318e89bd3d2d3e76bc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga3aa015ca35277318e89bd3d2d3e76bc4">triangulate</a> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:ga3aa015ca35277318e89bd3d2d3e76bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate the <a class="el" href="classpmp_1_1_face.html" title="this type represents a face (internally it is basically an index)">Face</a> <code>f</code> .  <br /></td></tr>
<tr class="separator:ga3aa015ca35277318e89bd3d2d3e76bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fec476ec9ff00c29ef3f3ae388e30b2"><td class="memItemLeft" align="right" valign="top"><a id="ga0fec476ec9ff00c29ef3f3ae388e30b2" name="ga0fec476ec9ff00c29ef3f3ae388e30b2"></a>
<a class="el" href="classpmp_1_1_bounding_box.html">BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bounds</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga0fec476ec9ff00c29ef3f3ae388e30b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounding box of <code>mesh</code> . <br /></td></tr>
<tr class="separator:ga0fec476ec9ff00c29ef3f3ae388e30b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab69d401c211502d183849e3778d79a4"><td class="memItemLeft" align="right" valign="top"><a id="gaab69d401c211502d183849e3778d79a4" name="gaab69d401c211502d183849e3778d79a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flip_faces</b> (<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gaab69d401c211502d183849e3778d79a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the orientation of all faces in <code>mesh</code> . <br /></td></tr>
<tr class="separator:gaab69d401c211502d183849e3778d79a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d8d82364eaffffa41a01aa34e5a35f"><td class="memItemLeft" align="right" valign="top"><a id="gae9d8d82364eaffffa41a01aa34e5a35f" name="gae9d8d82364eaffffa41a01aa34e5a35f"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>min_face_area</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:gae9d8d82364eaffffa41a01aa34e5a35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum area of all faces in <code>mesh</code> . <br /></td></tr>
<tr class="separator:gae9d8d82364eaffffa41a01aa34e5a35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73faf69000512c8b2d23bba5fe8423e"><td class="memItemLeft" align="right" valign="top"><a id="gaa73faf69000512c8b2d23bba5fe8423e" name="gaa73faf69000512c8b2d23bba5fe8423e"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>edge_length</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh, <a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:gaa73faf69000512c8b2d23bba5fe8423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute length of an edge <code>e</code> in <code>mesh</code> . <br /></td></tr>
<tr class="separator:gaa73faf69000512c8b2d23bba5fe8423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3b5653946144f416b8c7f34a09e2d4"><td class="memItemLeft" align="right" valign="top"><a id="ga4e3b5653946144f416b8c7f34a09e2d4" name="ga4e3b5653946144f416b8c7f34a09e2d4"></a>
<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mean_edge_length</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ga4e3b5653946144f416b8c7f34a09e2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mean edge length of <code>mesh</code> . <br /></td></tr>
<tr class="separator:ga4e3b5653946144f416b8c7f34a09e2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Mesh processing algorithms. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab0bc5cf882dd9adfbf56f396bde50fa6" name="gab0bc5cf882dd9adfbf56f396bde50fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0bc5cf882dd9adfbf56f396bde50fa6">&#9670;&#160;</a></span>Curvature</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__algorithms.html#gab0bc5cf882dd9adfbf56f396bde50fa6">Curvature</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of curvature to be computed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab0bc5cf882dd9adfbf56f396bde50fa6ad8bd79cc131920d5de426f914d17405a" name="ggab0bc5cf882dd9adfbf56f396bde50fa6ad8bd79cc131920d5de426f914d17405a"></a>min&#160;</td><td class="fielddoc"><p>minimum curvature </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0bc5cf882dd9adfbf56f396bde50fa6a2ffe4e77325d9a7152f7086ea7aa5114" name="ggab0bc5cf882dd9adfbf56f396bde50fa6a2ffe4e77325d9a7152f7086ea7aa5114"></a>max&#160;</td><td class="fielddoc"><p>maximum curvature </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0bc5cf882dd9adfbf56f396bde50fa6ab93db188572fc4d76cce5660f3823b0a" name="ggab0bc5cf882dd9adfbf56f396bde50fa6ab93db188572fc4d76cce5660f3823b0a"></a>mean&#160;</td><td class="fielddoc"><p>mean curvature </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0bc5cf882dd9adfbf56f396bde50fa6a710a4950250286365cf841f765a790f1" name="ggab0bc5cf882dd9adfbf56f396bde50fa6a710a4950250286365cf841f765a790f1"></a>gauss&#160;</td><td class="fielddoc"><p>Gauss curvature. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0bc5cf882dd9adfbf56f396bde50fa6a18077475a61518baca9368b586797902" name="ggab0bc5cf882dd9adfbf56f396bde50fa6a18077475a61518baca9368b586797902"></a>max_abs&#160;</td><td class="fielddoc"><p>maximum absolute curvature </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaee81c99c293038da58ede01416bf8026" name="gaee81c99c293038da58ede01416bf8026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee81c99c293038da58ede01416bf8026">&#9670;&#160;</a></span>adaptive_remeshing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adaptive_remeshing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>min_edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>max_edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>approx_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_projection</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform adaptive remeshing. </p>
<p>Performs incremental remeshing based on edge collapse, split, flip, and tangential relaxation. See <a class="el" href="citelist.html#CITEREF_botsch_2004_remeshing">[2]</a> and <a class="el" href="citelist.html#CITEREF_dunyach_2013_adaptive">[10]</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh, modified in place. </td></tr>
    <tr><td class="paramname">min_edge_length</td><td>The minimum edge length. </td></tr>
    <tr><td class="paramname">max_edge_length</td><td>The maximum edge length. </td></tr>
    <tr><td class="paramname">approx_error</td><td>The maximum approximation error. </td></tr>
    <tr><td class="paramname">iterations</td><td>The number of iterations. </td></tr>
    <tr><td class="paramname">use_projection</td><td>Use back-projection to the input surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>if the input precondition is violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8904821f0ffb041f98a829595a4bbb81" name="ga8904821f0ffb041f98a829595a4bbb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8904821f0ffb041f98a829595a4bbb81">&#9670;&#160;</a></span>catmull_clark_subdivision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void catmull_clark_subdivision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform one step of Catmull-Clark subdivision. </p>
<p>See <a class="el" href="citelist.html#CITEREF_catmull_1978_recursively">[5]</a> for details. </p>

</div>
</div>
<a id="gaa4171cccd05b114b3235b55273766e19" name="gaa4171cccd05b114b3235b55273766e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4171cccd05b114b3235b55273766e19">&#9670;&#160;</a></span>clear_features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear feature and boundary edges. </p>
<p>Sets all <code>"e:feature"</code> and <code>"v:feature"</code> properties to <code>false</code>. </p><dl class="section note"><dt>Note</dt><dd>This does not remove the corresponding property arrays. </dd></dl>

</div>
</div>
<a id="ga4cbc6cb993b7276c98aa6f94bf932f1b" name="ga4cbc6cb993b7276c98aa6f94bf932f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cbc6cb993b7276c98aa6f94bf932f1b">&#9670;&#160;</a></span>cone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> cone </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>height</em> = <code>2.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a cone mesh. </p>
<p>Generates a polygonal mesh of a cone. The circular base lies in the x-y-plane and the tip points in positive z-direction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_subdivisions</td><td>Number of subdivisions of the base circle. Needs to be &gt;= 3. Default: 30. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the base circle. Default: 1. </td></tr>
    <tr><td class="paramname">height</td><td>Height of the the cone. Default: 2.5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a7fbd36d795764476f3d5cfbd720273" name="ga2a7fbd36d795764476f3d5cfbd720273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a7fbd36d795764476f3d5cfbd720273">&#9670;&#160;</a></span>coordinates_to_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coordinates_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepmp.html#ad57866758e73ec85f27ca57c46510795">DenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a mesh with N vertices, construct an Nx3 matrix containing the vertex coordinates in its rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">X</td><td>The output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e83a7ab6b982b4bfd33f60db107077f" name="ga9e83a7ab6b982b4bfd33f60db107077f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e83a7ab6b982b4bfd33f60db107077f">&#9670;&#160;</a></span>corner_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gacf26e6cb89ee46863792074a1d0a280b">Normal</a> corner_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>crease_angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the normal vector of the polygon corner specified by the target vertex of halfedge <code>h</code>. </p>
<p>Averages incident corner normals if they are within crease_angle of the face normal. <code>crease_angle</code> is in radians, not degrees. </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="ga16503985229c4c2730cd0f76ba3153cb" name="ga16503985229c4c2730cd0f76ba3153cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16503985229c4c2730cd0f76ba3153cb">&#9670;&#160;</a></span>cotan_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cotan_weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the cotangent weight for edge e </p>
<dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>

</div>
</div>
<a id="ga996dfb6992b4c623528f27664990deb5" name="ga996dfb6992b4c623528f27664990deb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996dfb6992b4c623528f27664990deb5">&#9670;&#160;</a></span>curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__algorithms.html#gab0bc5cf882dd9adfbf56f396bde50fa6">Curvature</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="group__algorithms.html#ggab0bc5cf882dd9adfbf56f396bde50fa6ab93db188572fc4d76cce5660f3823b0a">Curvature::mean</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smoothing_steps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_tensor</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_two_ring</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute per-vertex curvature (min,max,mean,Gaussian). </p>
<p>Curvature values for boundary vertices are interpolated from their interior neighbors. Curvature values can be smoothed. See <a class="el" href="citelist.html#CITEREF_meyer_2003_discrete">[18]</a> and <a class="el" href="citelist.html#CITEREF_cohen-steiner_2003_restricted">[6]</a> for details. </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="ga6b2ed056e1accab921da9142ab7c4568" name="ga6b2ed056e1accab921da9142ab7c4568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2ed056e1accab921da9142ab7c4568">&#9670;&#160;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> cylinder </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>height</em> = <code>2.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a cylinder mesh. </p>
<p>Generates a polygonal mesh of a cylinder. The cylinder is oriented in z-direction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_subdivisions</td><td>Number of subdivisions of the cylinder. Needs to be &gt;= 3. Default: 30. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the cylinder. Default: 1. </td></tr>
    <tr><td class="paramname">height</td><td>Height of the cylinder. Default: 2.5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0ddc5af06c944e6bf29b3424704ab9f" name="gae0ddc5af06c944e6bf29b3424704ab9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0ddc5af06c944e6bf29b3424704ab9f">&#9670;&#160;</a></span>decimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>aspect_ratio</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>edge_length</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_valence</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>normal_deviation</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>hausdorff_error</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>seam_threshold</em> = <code>1e-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>seam_angle_deviation</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mesh decimation based on approximation error and fairness criteria. </p>
<p>Performs incremental greedy mesh decimation based on halfedge collapses. See <a class="el" href="citelist.html#CITEREF_kobbelt_1998_general">[14]</a> and <a class="el" href="citelist.html#CITEREF_garland_1997_surface">[11]</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Target mesh. Modified in place. </td></tr>
    <tr><td class="paramname">n_vertices</td><td>Target number of vertices. </td></tr>
    <tr><td class="paramname">aspect_ratio</td><td>Minimum aspect ratio of the triangles. </td></tr>
    <tr><td class="paramname">edge_length</td><td>Minimum target edge length. </td></tr>
    <tr><td class="paramname">max_valence</td><td>Maximum number of incident edges per vertex. </td></tr>
    <tr><td class="paramname">normal_deviation</td><td>Maximum deviation of face normals. </td></tr>
    <tr><td class="paramname">hausdorff_error</td><td>Maximum deviation from the original surface. </td></tr>
    <tr><td class="paramname">seam_threshold</td><td>Threshold for texture seams. </td></tr>
    <tr><td class="paramname">seam_angle_deviation</td><td>Maximum texture seam deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>if the input precondition is violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9238a9388000b87d264c559487a65372" name="ga9238a9388000b87d264c559487a65372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9238a9388000b87d264c559487a65372">&#9670;&#160;</a></span>detect_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t detect_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark all boundary edges as features. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of boundary edges detected. </dd></dl>

</div>
</div>
<a id="gaffad2e6a6859e0085355605048884f7f" name="gaffad2e6a6859e0085355605048884f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffad2e6a6859e0085355605048884f7f">&#9670;&#160;</a></span>detect_features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t detect_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark edges with dihedral angle larger than <code>angle</code> as feature. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of feature edges detected. </dd></dl>

</div>
</div>
<a id="gadf2fab8863491412591b0b3ee13dfddf" name="gadf2fab8863491412591b0b3ee13dfddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf2fab8863491412591b0b3ee13dfddf">&#9670;&#160;</a></span>divergence_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void divergence_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the cotan divergence matrix. </p>
<p><a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">Matrix</a> is sparse and maps constant gradient vectors at non-boundary halfedges to values at vertices. The discrete operators are consistent, such that Laplacian is divergence of gradient. See <a class="el" href="citelist.html#CITEREF_meyer_2003_discrete">[18]</a> for details on triangle meshes and <a class="el" href="citelist.html#CITEREF_bunge_2020_polygon">[4]</a> for details on polygon meshes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">D</td><td>The output matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__algorithms.html#ga05321dedc35a3043d5cec49087cad399" title="Construct the cotan Laplace matrix.">laplace_matrix</a> </dd>
<dd>
<a class="el" href="group__algorithms.html#ga29c8e7f45d4ea5de4e1af8497a2a415d" title="Construct the cotan gradient matrix.">gradient_matrix</a> </dd></dl>

</div>
</div>
<a id="gac2da4e0cf0776841129157eded85dd76" name="gac2da4e0cf0776841129157eded85dd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2da4e0cf0776841129157eded85dd76">&#9670;&#160;</a></span>dual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute dual of a mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>Changes the mesh in place. All properties are cleared. </dd></dl>

</div>
</div>
<a id="gabfa24662ed3dcb46496f9da995ebc18d" name="gabfa24662ed3dcb46496f9da995ebc18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfa24662ed3dcb46496f9da995ebc18d">&#9670;&#160;</a></span>explicit_smoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void explicit_smoothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_uniform_laplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform explicit Laplacian smoothing. </p>
<p>See <a class="el" href="citelist.html#CITEREF_desbrun_1999_implicit">[8]</a> for details </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh, modified in place. </td></tr>
    <tr><td class="paramname">iterations</td><td>The number of iterations performed. </td></tr>
    <tr><td class="paramname">use_uniform_laplace</td><td>Use uniform or cotan Laplacian. Default: cotan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga435e465f8829b584ea80ffee23abfd0f" name="ga435e465f8829b584ea80ffee23abfd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga435e465f8829b584ea80ffee23abfd0f">&#9670;&#160;</a></span>face_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> face_area </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute area of face <code>f</code>. </p>
<p>Computes standard area for triangles and norm of vector area for other polygons. </p>

</div>
</div>
<a id="ga7343f7734686d6ede26f20ef3f11b736" name="ga7343f7734686d6ede26f20ef3f11b736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7343f7734686d6ede26f20ef3f11b736">&#9670;&#160;</a></span>face_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gacf26e6cb89ee46863792074a1d0a280b">Normal</a> face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the normal vector of face <code>f</code>. </p>
<p>Normal is computed as (normalized) sum of per-corner cross products of the two incident edges. This corresponds to the normalized vector area in <a class="el" href="citelist.html#CITEREF_alexa_2011_laplace">[1]</a> </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="gadbdfb991afd1ba49d6ae568fffdc4c44" name="gadbdfb991afd1ba49d6ae568fffdc4c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbdfb991afd1ba49d6ae568fffdc4c44">&#9670;&#160;</a></span>face_normals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void face_normals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute face normals for the whole <code>mesh</code>. </p>
<p>Calls <a class="el" href="group__algorithms.html#ga7343f7734686d6ede26f20ef3f11b736" title="Compute the normal vector of face f.">face_normal()</a> for each face and adds a new face property of type Normal named "f:normal". </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="gaf088d924e73a287814117be95e066e65" name="gaf088d924e73a287814117be95e066e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf088d924e73a287814117be95e066e65">&#9670;&#160;</a></span>fair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implicit surface fairing. </p>
<p>Computes a surface by solving k-harmonic equation. See also <a class="el" href="citelist.html#CITEREF_desbrun_1999_implicit">[8]</a> . </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_solver_exception.html" title="Exception indicating failure so solve an equation system.">SolverException</a></td><td>in case of failure to solve the linear system </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>in case of missing boundary constraints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaca9b37cec9b172bb897b8db8941b457" name="gaaca9b37cec9b172bb897b8db8941b457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca9b37cec9b172bb897b8db8941b457">&#9670;&#160;</a></span>fill_hole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the hole specified by halfedge <code>h</code>. </p>
<p>Close simple holes (boundary loops of manifold vertices) by first filling the hole with an angle/area-minimizing triangulation, followed by isometric remeshing, and finished by curvature-minimizing fairing of the filled-in patch. See <a class="el" href="citelist.html#CITEREF_liepa_2003_filling">[15]</a> for details. </p><dl class="section pre"><dt>Precondition</dt><dd>The specified halfedge is valid. </dd>
<dd>
The specified halfedge is a boundary halfedge. </dd>
<dd>
The specified halfedge is not adjacent to a non-manifold hole. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>in case on of the input preconditions is violated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="gac111fa556be1ce658f8994ccd29e514d" name="gac111fa556be1ce658f8994ccd29e514d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac111fa556be1ce658f8994ccd29e514d">&#9670;&#160;</a></span>geodesics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int geodesics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>maxdist</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;&gt;<a class="el" href="group__core.html#ga1df4a4cb5ca6aead30088c56290caf1e">::max</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxnum</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;<a class="el" href="group__core.html#ga1df4a4cb5ca6aead30088c56290caf1e">::max</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; *&#160;</td>
          <td class="paramname"><em>neighbors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute geodesic distance from a set of seed vertices. </p>
<p>The method works by a Dijkstra-like breadth first traversal from the seed vertices, implemented by a heap structure. See <a class="el" href="citelist.html#CITEREF_kimmel_1998_geodesic">[13]</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td>The input mesh, modified in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seeds</td><td>The vector of seed vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxdist</td><td>The maximum distance up to which to compute the geodesic distances. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxnum</td><td>The maximum number of neighbors up to which to compute the geodesic distances. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbors</td><td>The vector of neighbor vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of neighbors that have been found. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>

</div>
</div>
<a id="gac10a5c5209c0e72ba7dd03a00d2f662a" name="gac10a5c5209c0e72ba7dd03a00d2f662a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10a5c5209c0e72ba7dd03a00d2f662a">&#9670;&#160;</a></span>geodesics_heat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geodesics_heat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute geodesic distance from a set of seed vertices. </p>
<p>Compute geodesic distances based on the heat method, by solving two Poisson systems. Works on general polygon meshes. See <a class="el" href="citelist.html#CITEREF_crane_2013_geodesics">[7]</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh, modified in place. </td></tr>
    <tr><td class="paramname">seeds</td><td>The vector of seed vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="ga29c8e7f45d4ea5de4e1af8497a2a415d" name="ga29c8e7f45d4ea5de4e1af8497a2a415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c8e7f45d4ea5de4e1af8497a2a415d">&#9670;&#160;</a></span>gradient_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gradient_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the cotan gradient matrix. </p>
<p><a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">Matrix</a> is sparse and maps values at vertices to constant gradient 3D-vectors at non-boundary halfedges. The discrete operators are consistent, such that Laplacian is divergence of gradient. See <a class="el" href="citelist.html#CITEREF_meyer_2003_discrete">[18]</a> for details on triangle meshes and <a class="el" href="citelist.html#CITEREF_bunge_2020_polygon">[4]</a> for details on polygon meshes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">G</td><td>The output matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__algorithms.html#ga05321dedc35a3043d5cec49087cad399" title="Construct the cotan Laplace matrix.">laplace_matrix</a> </dd>
<dd>
<a class="el" href="group__algorithms.html#gadf2fab8863491412591b0b3ee13dfddf" title="Construct the cotan divergence matrix.">divergence_matrix</a> </dd></dl>

</div>
</div>
<a id="gaafdf2296336831cf5be5e6732b9fd301" name="gaafdf2296336831cf5be5e6732b9fd301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafdf2296336831cf5be5e6732b9fd301">&#9670;&#160;</a></span>harmonic_parameterization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void harmonic_parameterization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_uniform_weights</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute discrete harmonic parameterization. </p>
<p>See <a class="el" href="citelist.html#CITEREF_desbrun_2002_intrinsic">[9]</a> for details. </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The mesh has a boundary. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>if the input precondition is violated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_solver_exception.html" title="Exception indicating failure so solve an equation system.">SolverException</a></td><td>in case of failure to solve the linear system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="gaff49f97d35538c22214bcb08907578c4" name="gaff49f97d35538c22214bcb08907578c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff49f97d35538c22214bcb08907578c4">&#9670;&#160;</a></span>icosphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> icosphere </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate icosphere refined by <code>n_subdivisions</code> . </p>
<p>Uses Loop subdivision to refine the initial icosahedron. </p>

</div>
</div>
<a id="gad0e259304277c0853b3c1867b2bd8eab" name="gad0e259304277c0853b3c1867b2bd8eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0e259304277c0853b3c1867b2bd8eab">&#9670;&#160;</a></span>implicit_smoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void implicit_smoothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>timestep</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_uniform_laplace</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rescale</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform implicit Laplacian smoothing. </p>
<p>See <a class="el" href="citelist.html#CITEREF_desbrun_1999_implicit">[8]</a> and <a class="el" href="citelist.html#CITEREF_kazhdan_2012">[12]</a> . </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh, modified in place. </td></tr>
    <tr><td class="paramname">timestep</td><td>The time step taken. </td></tr>
    <tr><td class="paramname">iterations</td><td>The number of iterations performed. </td></tr>
    <tr><td class="paramname">use_uniform_laplace</td><td>Use uniform or cotan Laplacian. Default: cotan. </td></tr>
    <tr><td class="paramname">rescale</td><td>Re-center and re-scale model after smoothing. Default: true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_solver_exception.html" title="Exception indicating failure so solve an equation system.">SolverException</a></td><td>in case of a failure to solve the linear system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9733adae31befb562a66d76b2892a24f" name="ga9733adae31befb562a66d76b2892a24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9733adae31befb562a66d76b2892a24f">&#9670;&#160;</a></span>laplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> laplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute Laplace vector for vertex v (normalized by Voronoi area) </p>
<dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>

</div>
</div>
<a id="ga05321dedc35a3043d5cec49087cad399" name="ga05321dedc35a3043d5cec49087cad399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05321dedc35a3043d5cec49087cad399">&#9670;&#160;</a></span>laplace_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clamp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the cotan Laplace matrix. </p>
<p><a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">Matrix</a> is sparse, symmetric and negative semi-definite. M(i,i) is the negative valence of vertex i. M(i,j) is cotangent weight of edge (i,j). M(i,i) is negative sum of off-diagonals. The discrete operators are consistent, such that Laplacian is divergence of gradient. See <a class="el" href="citelist.html#CITEREF_meyer_2003_discrete">[18]</a> for details on triangle meshes and <a class="el" href="citelist.html#CITEREF_bunge_2020_polygon">[4]</a> for details on polygon meshes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">L</td><td>The output matrix. </td></tr>
    <tr><td class="paramname">clamp</td><td>Whether or not negative off-diagonal entries should be clamped to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__algorithms.html#ga29c8e7f45d4ea5de4e1af8497a2a415d" title="Construct the cotan gradient matrix.">gradient_matrix</a> </dd>
<dd>
<a class="el" href="group__algorithms.html#gadf2fab8863491412591b0b3ee13dfddf" title="Construct the cotan divergence matrix.">divergence_matrix</a> </dd></dl>

</div>
</div>
<a id="gae9902b2a584569ecb1cfaab42a70997d" name="gae9902b2a584569ecb1cfaab42a70997d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9902b2a584569ecb1cfaab42a70997d">&#9670;&#160;</a></span>loop_subdivision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loop_subdivision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform one step of Loop subdivision. </p>
<p>See <a class="el" href="citelist.html#CITEREF_loop_1987_smooth">[16]</a> for details. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires a triangle mesh as input. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>in case the input violates the precondition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga29f704761534c423c6adf1238e53bba0" name="ga29f704761534c423c6adf1238e53bba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f704761534c423c6adf1238e53bba0">&#9670;&#160;</a></span>lscm_parameterization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lscm_parameterization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute parameterization based on least squares conformal mapping. </p>
<p>See <a class="el" href="citelist.html#CITEREF_levy_2002_least">[17]</a> for details. </p><dl class="section pre"><dt>Precondition</dt><dd>The mesh has a boundary. </dd>
<dd>
Input mesh needs to be a triangle mesh. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>if the input precondition is violated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_solver_exception.html" title="Exception indicating failure so solve an equation system.">SolverException</a></td><td>in case of failure to solve the linear system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9523db1a9d004baa313eaa436afdde1e" name="ga9523db1a9d004baa313eaa436afdde1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9523db1a9d004baa313eaa436afdde1e">&#9670;&#160;</a></span>mass_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepmp.html#ae3249aafea03050084307e8b71f36be6">DiagonalMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the (lumped) mass matrix for the cotangent Laplacian. </p>
<p><a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">Matrix</a> is diagonal and positive definite. M(i,i) is the (mixed) Voronoi area of vertex i. See <a class="el" href="citelist.html#CITEREF_meyer_2003_discrete">[18]</a> for details on triangle meshes and <a class="el" href="citelist.html#CITEREF_bunge_2020_polygon">[4]</a> for details on polygon meshes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">M</td><td>The output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62cb07f432c4a57c565a3a2e480145a9" name="ga62cb07f432c4a57c565a3a2e480145a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62cb07f432c4a57c565a3a2e480145a9">&#9670;&#160;</a></span>matrix_to_coordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_to_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepmp.html#ad57866758e73ec85f27ca57c46510795">DenseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a mesh with N vertices, set the vertex coordinates from the rows of an Nx3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4a7bf250a882d91f9c7733a6a2c4f04" name="gaf4a7bf250a882d91f9c7733a6a2c4f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a7bf250a882d91f9c7733a6a2c4f04">&#9670;&#160;</a></span>minimize_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void minimize_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize surface area. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__algorithms.html#gaf088d924e73a287814117be95e066e65" title="Implicit surface fairing.">fair()</a> </dd></dl>

</div>
</div>
<a id="ga6ca2a564e3160dcf10a2c9061a9d5e8f" name="ga6ca2a564e3160dcf10a2c9061a9d5e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca2a564e3160dcf10a2c9061a9d5e8f">&#9670;&#160;</a></span>minimize_curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void minimize_curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize surface curvature. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__algorithms.html#gaf088d924e73a287814117be95e066e65" title="Implicit surface fairing.">fair()</a> </dd></dl>

</div>
</div>
<a id="gae29d243d897921e656396a218cc17db2" name="gae29d243d897921e656396a218cc17db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae29d243d897921e656396a218cc17db2">&#9670;&#160;</a></span>plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> plane </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>4</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a plane mesh. </p>
<p>Generates a pure quad mesh in the x-y plane with origin (0,0,0) and side length 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>Number of faces in each direction. Needs to be &gt;= 1. Default: 4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2fdffc976f947cf3e7911461295a9737" name="ga2fdffc976f947cf3e7911461295a9737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fdffc976f947cf3e7911461295a9737">&#9670;&#160;</a></span>quad_sphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> quad_sphere </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate quad sphere refined by <code>n_subdivisions</code> . </p>
<p>Uses Catmull-Clark subdivision to refine the initial hexahedron. </p>

</div>
</div>
<a id="ga6c2980af4c4d5308b711f92431a0f80d" name="ga6c2980af4c4d5308b711f92431a0f80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c2980af4c4d5308b711f92431a0f80d">&#9670;&#160;</a></span>quad_tri_subdivision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quad_tri_subdivision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform one step of quad-tri subdivision. </p>
<p>Suitable for mixed quad/triangle meshes. See <a class="el" href="citelist.html#CITEREF_stam_2003_subdiv">[22]</a> for details. </p>

</div>
</div>
<a id="gae7d933cd48c728f9f45cd61c26a40e25" name="gae7d933cd48c728f9f45cd61c26a40e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7d933cd48c728f9f45cd61c26a40e25">&#9670;&#160;</a></span>torus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> torus </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>radial_resolution</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tubular_resolution</em> = <code>40</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>thickness</em> = <code>0.4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a torus mesh. </p>
<p>Generates a quad mesh of a torus with its major circle in the x-y plane. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radial_resolution</td><td>Number of subdivisions of the major circle. Needs to be &gt;= 3. Default: 20. </td></tr>
    <tr><td class="paramname">tubular_resolution</td><td>Number of subdivisions of along the tube. Needs to be &gt;= 3. Default: 40. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the major circle. Default: 1. </td></tr>
    <tr><td class="paramname">thickness</td><td>Thickness of the tube. Default: 0.4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3aa015ca35277318e89bd3d2d3e76bc4" name="ga3aa015ca35277318e89bd3d2d3e76bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aa015ca35277318e89bd3d2d3e76bc4">&#9670;&#160;</a></span>triangulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulate the <a class="el" href="classpmp_1_1_face.html" title="this type represents a face (internally it is basically an index)">Face</a> <code>f</code> . </p>
<p>Triangulate n-gons into n-2 triangles. Finds the triangulation that minimizes the sum of squared triangle areas. See <a class="el" href="citelist.html#CITEREF_liepa_2003_filling">[15]</a> for details. </p><dl class="section pre"><dt>Precondition</dt><dd>The input face is manifold </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>in case the input precondition is violated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6371fadb0df9378b3422b815c0bf189" name="gab6371fadb0df9378b3422b815c0bf189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6371fadb0df9378b3422b815c0bf189">&#9670;&#160;</a></span>uniform_laplace_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uniform_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepmp.html#a9940953f4586dd71fecaa45555ef146a">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the uniform Laplace matrix. </p>
<p><a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">Matrix</a> is sparse, symmetric and negative semi-definite. M(i,i) is the negative valence of vertex i. M(i,j) is +1 if vertex i and vertex j are neighbors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">L</td><td>The output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8fec1c728d2fafe2b201be4214898cef" name="ga8fec1c728d2fafe2b201be4214898cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fec1c728d2fafe2b201be4214898cef">&#9670;&#160;</a></span>uniform_mass_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uniform_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepmp.html#ae3249aafea03050084307e8b71f36be6">DiagonalMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the mass matrix for the uniform Laplacian. </p>
<p><a class="el" href="classpmp_1_1_matrix.html" title="Base class for MxN matrix.">Matrix</a> is diagonal and positive definite. M(i,i) is the valence of vertex i. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">M</td><td>The output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ddecfc2d08f5dbf820863acc79ee3bc" name="ga1ddecfc2d08f5dbf820863acc79ee3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ddecfc2d08f5dbf820863acc79ee3bc">&#9670;&#160;</a></span>uniform_remeshing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uniform_remeshing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a>&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_projection</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform uniform remeshing. </p>
<p>Performs incremental remeshing based on edge collapse, split, flip, and tangential relaxation. See <a class="el" href="citelist.html#CITEREF_botsch_2004_remeshing">[2]</a> and <a class="el" href="citelist.html#CITEREF_dunyach_2013_adaptive">[10]</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh, modified in place. </td></tr>
    <tr><td class="paramname">edge_length</td><td>The target edge length. </td></tr>
    <tr><td class="paramname">iterations</td><td>The number of iterations </td></tr>
    <tr><td class="paramname">use_projection</td><td>Use back-projection to the input surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>if the input precondition is violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5fb42aa6dc03649f6078d3baeba7654" name="gac5fb42aa6dc03649f6078d3baeba7654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5fb42aa6dc03649f6078d3baeba7654">&#9670;&#160;</a></span>vertex_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gacf26e6cb89ee46863792074a1d0a280b">Normal</a> vertex_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the normal vector of vertex <code>v</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="gaa35975622025fb0fb0b9d6c70f1c1b6b" name="gaa35975622025fb0fb0b9d6c70f1c1b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa35975622025fb0fb0b9d6c70f1c1b6b">&#9670;&#160;</a></span>vertex_normals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vertex_normals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute vertex normals for the whole <code>mesh</code>. </p>
<p>Calls <a class="el" href="group__algorithms.html#gac5fb42aa6dc03649f6078d3baeba7654" title="Compute the normal vector of vertex v.">vertex_normal()</a> for each vertex and adds a new vertex property of type Normal named "v:normal". </p><dl class="section note"><dt>Note</dt><dd>This algorithm works on general polygon meshes. </dd></dl>

</div>
</div>
<a id="ga83dfe15cf2f00acfdd1c06eb4347e629" name="ga83dfe15cf2f00acfdd1c06eb4347e629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83dfe15cf2f00acfdd1c06eb4347e629">&#9670;&#160;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the volume of a mesh. </p>
<p>See <a class="el" href="citelist.html#CITEREF_zhang_2002_efficient">[24]</a> for details. </p><dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_invalid_input_exception.html" title="Exception indicating invalid input passed to a function.">InvalidInputException</a></td><td>if the input precondition is violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93ed1bf4ffbfb0fb6fd582cdb0019b1c" name="ga93ed1bf4ffbfb0fb6fd582cdb0019b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93ed1bf4ffbfb0fb6fd582cdb0019b1c">&#9670;&#160;</a></span>voronoi_area_mixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga4be45d931ceeeea4be9f14978f30e498">Scalar</a> voronoi_area_mixed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mixed Voronoi area of a vertex. </p>
<p>This version is preferred for irregular triangles with obtuse angles. See <a class="el" href="citelist.html#CITEREF_meyer_2003_discrete">[18]</a> for details. </p><dl class="section pre"><dt>Precondition</dt><dd>Input mesh needs to be a triangle mesh. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath">
  <address>
    Copyright  2011-2023 the Polygon Mesh Processing Library developers.
  </address>
</div>
</body>
</html>